import subprocess
from pathlib import Path

from launchkit.core.git_tools import setup_git
from launchkit.modules.addon_management import choose_addons, apply_addons, add_new_addons
from launchkit.modules.server_management import running_processes, run_dev_server, server_management_menu, \
    cleanup_processes
from launchkit.utils.display_utils import *
from launchkit.utils.enum_utils import PROJECT_TYPES, STACK_CATALOG, SCAFFOLDERS
from launchkit.utils.que import Question
from launchkit.utils.support_utils import deploy_with_docker, deploy_to_kubernetes, setup_automated_deployment, \
    show_manual_deployment_guide
from launchkit.utils.user_utils import add_data_to_db, create_backup


def choose_project_type() -> str:
    project_type = Question("Select your project type:", PROJECT_TYPES).ask()
    if project_type not in PROJECT_TYPES:
        exiting_program()
        sys.exit(1)
    return project_type


def choose_stack(project_type: str) -> str:
    stacks = STACK_CATALOG.get(project_type, [])
    if not stacks:
        status_message("No stacks configured for this project type.", False)
        exiting_program()
        sys.exit(1)

    stack = Question(f"Select a tech stack for '{project_type}':", stacks).ask()
    if stack not in stacks:
        exiting_program()
        sys.exit(1)
    return stack


def run_scaffolding(stack: str, folder: Path):
    scaffold = SCAFFOLDERS.get(stack)
    if not scaffold:
        status_message(f"No scaffolder registered for '{stack}'.", False)
        exiting_program()
        sys.exit(1)
    scaffold(folder)


def create_project_summary(data: dict, folder: Path):
    """Create a project summary file with all configurations."""
    summary_content = f"""# {folder.name} - Project Summary

## Project Configuration
- **Project Type:** {data.get('project_type', 'N/A')}
- **Tech Stack:** {data.get('project_stack', 'N/A')}
- **Created:** {data.get('created_date', 'Today')}
- **User:** {data.get('user_name', 'Unknown')}

## Features Enabled
"""

    addons = data.get('addons', [])
    if addons:
        for addon in addons:
            summary_content += f"- {addon}\n"
    else:
        summary_content += "- No additional features enabled\n"

    summary_content += f"""
## Directory Structure
```
{folder.name}/
‚îú‚îÄ‚îÄ src/                 # Source code
‚îú‚îÄ‚îÄ tests/              # Test files
"""

    if "Add Docker Support" in addons:
        summary_content += """‚îú‚îÄ‚îÄ Dockerfile          # Docker configuration
‚îú‚îÄ‚îÄ docker-compose.yml  # Docker Compose setup
‚îú‚îÄ‚îÄ .dockerignore      # Docker ignore rules
"""

    if "Add Kubernetes Support" in addons:
        summary_content += """‚îú‚îÄ‚îÄ k8s/               # Kubernetes manifests
‚îÇ   ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ service.yaml
‚îÇ   ‚îî‚îÄ‚îÄ kustomization.yaml
"""

    if "Add CI (GitHub Actions)" in addons:
        summary_content += """‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ ci.yml     # CI/CD pipeline
"""

    summary_content += """‚îú‚îÄ‚îÄ .git/              # Git repository
‚îú‚îÄ‚îÄ .gitignore         # Git ignore rules
‚îî‚îÄ‚îÄ README.md          # Project documentation
```

## Getting Started

### Development
```bash
# Navigate to project directory
cd """ + str(folder) + """

# Install dependencies (if applicable)
npm install  # or pip install -r requirements.txt
"""

    if "Add Docker Support" in addons:
        summary_content += """
### Docker
```bash
# Build and run with Docker
docker-compose up --build

# Or build and run separately
docker build -t """ + folder.name + """ .
docker run -p 3000:3000 """ + folder.name + """
```
"""

    if "Add Kubernetes Support" in addons:
        summary_content += """
### Kubernetes
```bash
# Apply Kubernetes manifests
kubectl apply -f k8s/

# Or use Kustomize
kubectl apply -k k8s/

# Check deployment status
kubectl get pods
kubectl get services
```
"""

    summary_content += """
### Testing
```bash
# Run tests
npm test  # or pytest
```

## Next Steps
1. Update the README.md with project-specific information
2. Configure environment variables as needed
3. Set up your development environment
4. Start building your application!

---
Generated by LaunchKIT
"""

    (folder / "PROJECT_SUMMARY.md").write_text(summary_content, encoding='utf-8')
    status_message("Project summary created: PROJECT_SUMMARY.md")


def setup_new_project(data, folder):
    """Handle the initial project setup flow."""
    # Step 1: Project type
    ptype = choose_project_type()
    data["project_type"] = ptype
    rich_message(f"Project type selected: {ptype}")

    # Step 2: Stack under that type
    stack = choose_stack(ptype)
    data["project_stack"] = stack
    boxed_message(f"Tech stack selected: {stack}")

    # Initialize Git early
    setup_git(folder)
    data["git_setup"] = True

    # Step 3: Add-ons (with improved UI)
    addons = choose_addons()
    if addons:
        arrow_message(f"Add-ons selected: {', '.join(addons)}")
        data["addons"] = addons
    else:
        arrow_message("No add-ons selected.")
        data["addons"] = []

    # Step 4: Scaffold project
    progress_message("Setting up project structure...")
    run_scaffolding(stack, folder)
    data["stack_scaffolding"] = True

    # Step 5: Apply add-ons
    apply_addons(addons, folder, stack)
    data["addons_scaffolding"] = True

    # Step 6: Create project summary
    import datetime
    data["created_date"] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    create_project_summary(data, folder)

    # Mark setup as complete
    data["setup_complete"] = True
    data["project_status"] = "ready"

    # Step 7: Save to database
    add_data_to_db(data, str(folder))

    # Final success message
    boxed_message("üéâ Initial Setup Complete!")
    status_message("Your project template is ready!")
    arrow_message(f"Project location: {folder}")
    arrow_message("Check PROJECT_SUMMARY.md for detailed information")
    boxed_message("Run LaunchKIT again to access development tools! üöÄ")


def handle_existing_project(data, folder):
    """Handle operations for existing/configured projects."""
    project_name = data.get("project_name", "Unknown Project")
    stack = data.get("project_stack", "Unknown Stack")

    boxed_message(f"Welcome back to {project_name}!")
    arrow_message(f"Tech Stack: {stack}")
    arrow_message(f"Project Folder: {folder}")

    # Show current server status if any
    if 'dev_server' in running_processes and running_processes['dev_server']['process'].poll() is None:
        rich_message("Development server is currently running")

    # Show next steps menu
    next_steps_menu = [
        "üöÄ Run Development Server",
        "üèóÔ∏è  Build for Production",
        "üß™ Run Tests",
        "üì¶ Deploy Application",
        "‚öôÔ∏è  Project Management",
        "üîß Manage Running Services",
        "‚ùå Exit"
    ]

    while True:
        action = Question("What would you like to do?", next_steps_menu).ask()

        if "Development Server" in action:
            run_dev_server(data, folder)
        elif "Production" in action:
            build_production(data, folder)
        elif "Tests" in action:
            run_tests(data, folder)
        elif "Deploy" in action:
            deploy_app(data, folder)
        elif "Project Management" in action:
            project_management_menu(data, folder)
        elif "Running Services" in action:
            if 'dev_server' in running_processes:
                server_management_menu(data, folder)
            else:
                status_message("No services are currently running", False)
                arrow_message("Start the development server first!")
        elif "Exit" in action:
            cleanup_processes()
            rich_message("Happy coding! üöÄ")
            break


def project_management_menu(data, folder):
    """Handle project management tasks."""
    management_options = [
        "Add New Features/Add-ons",
        "Update Dependencies",
        "View Project Summary",
        "Backup Project",
        "Manage Running Services",
        "Open Project Folder",
        "Reset Project Configuration",
        "Back to Main Menu"
    ]

    while True:
        choice = Question("Project Management:", management_options).ask()

        if "Add New" in choice:
            add_new_addons(data, folder)
        elif "Update Dependencies" in choice:
            update_dependencies(data, folder)
        elif "View Project" in choice:
            view_project_summary(folder)
        elif "Backup" in choice:
            create_backup(Path(folder))
        elif "Running Services" in choice:
            if 'dev_server' in running_processes:
                server_management_menu(data, folder)
            else:
                status_message("No services are currently running", False)
        elif "Open Project" in choice:
            open_project_folder(folder)
        elif "Reset" in choice:
            reset_project_config(data, folder)
        elif "Back" in choice:
            break


def build_production(data, folder):
    """Build for production based on stack."""
    stack = data.get("project_stack", "")
    project_name = data.get("project_name", "Unknown")

    progress_message(f"Building {project_name} for production...")

    if any(tech in stack for tech in ["React", "Node.js", "MERN", "PERN"]):
        rich_message("Building React/Node.js application...")
        try:
            result = subprocess.run(["npm", "run", "build"], cwd=folder, capture_output=True, text=True)
            if result.returncode == 0:
                status_message("‚úÖ Production build completed successfully!", True)
                arrow_message("Build files are typically in the 'build' or 'dist' folder")
            else:
                status_message(f"‚ùå Build failed: {result.stderr}", False)
        except Exception as e:
            status_message(f"‚ùå Build error: {e}", False)

    elif "Flask" in stack:
        rich_message("Preparing Flask for production...")
        create_flask_production_config(folder)

    elif "Django" in stack:
        rich_message("Preparing Django for production...")
        try:
            result = subprocess.run(["python", "manage.py", "collectstatic", "--noinput"], cwd=folder,
                                    capture_output=True, text=True)
            if result.returncode == 0:
                status_message("‚úÖ Static files collected for production!", True)
            else:
                status_message(f"‚ùå Static collection failed: {result.stderr}", False)
        except Exception as e:
            status_message(f"‚ùå Production setup error: {e}", False)
    else:
        status_message(f"Production build not configured for {stack}", False)
        arrow_message("You can manually build your project in the project folder")


def run_tests(data, folder):
    """Run tests based on configured testing framework."""
    stack = data.get("project_stack", "")
    project_name = data.get("project_name", "Unknown")

    progress_message(f"Running tests for {project_name}...")

    try:
        if any(tech in stack for tech in ["React", "Node.js", "MERN", "PERN"]):
            if (folder / "jest.config.json").exists():
                result = subprocess.run(["npm", "test"], cwd=folder, capture_output=True, text=True)
            elif (folder / "vitest.config.js").exists():
                result = subprocess.run(["npm", "run", "test"], cwd=folder, capture_output=True, text=True)
            elif (folder / "package.json").exists():
                result = subprocess.run(["npm", "test"], cwd=folder, capture_output=True, text=True)
            else:
                status_message("No test configuration found", False)
                return

        elif any(tech in stack for tech in ["Flask", "Python"]):
            if (folder / "pytest.ini").exists():
                result = subprocess.run(["python", "-m", "pytest", "-v"], cwd=folder, capture_output=True, text=True)
            else:
                result = subprocess.run(["python", "-m", "unittest", "discover", "tests"], cwd=folder,
                                        capture_output=True, text=True)
        else:
            status_message("Test runner not configured for this stack", False)
            return

        if result.returncode == 0:
            status_message("‚úÖ All tests passed!", True)
            if result.stdout:
                rich_message("Test output (last few lines):")
                lines = result.stdout.strip().split('\n')[-5:]  # Show last 5 lines
                for line in lines:
                    arrow_message(line)
        else:
            status_message("‚ùå Some tests failed!", False)
            if result.stderr:
                rich_message("Error output:")
                arrow_message(result.stderr.strip())

    except Exception as e:
        status_message(f"‚ùå Error running tests: {e}", False)


def update_dependencies(data, folder):
    """Update project dependencies."""
    stack = data.get("project_stack", "")

    progress_message("Updating dependencies...")

    try:
        if any(tech in stack for tech in ["React", "Node.js", "MERN", "PERN"]):
            rich_message("Updating npm dependencies...")
            result = subprocess.run(["npm", "update"], cwd=folder, capture_output=True, text=True)
            if result.returncode == 0:
                status_message("‚úÖ npm dependencies updated successfully!", True)
            else:
                status_message(f"‚ùå npm update failed: {result.stderr}", False)

        elif any(tech in stack for tech in ["Flask", "Python"]):
            if (folder / "requirements.txt").exists():
                rich_message("Updating pip dependencies...")
                result = subprocess.run(["pip", "install", "--upgrade", "-r", "requirements.txt"], cwd=folder,
                                        capture_output=True, text=True)
                if result.returncode == 0:
                    status_message("‚úÖ pip dependencies updated successfully!", True)
                else:
                    status_message(f"‚ùå pip update failed: {result.stderr}", False)
            else:
                status_message("requirements.txt not found", False)
        else:
            status_message("Dependency update not configured for this stack", False)

    except Exception as e:
        status_message(f"‚ùå Error updating dependencies: {e}", False)


def view_project_summary(folder):
    """Display project summary."""
    summary_file = folder / "PROJECT_SUMMARY.md"
    if summary_file.exists():
        boxed_message("üìã Project Summary")
        try:
            content = summary_file.read_text()
            # Show first part of the summary
            lines = content.split('\n')[:25]  # First 25 lines
            for line in lines:
                if line.strip():
                    if line.startswith('#'):
                        rich_message(line)
                    else:
                        print(line)

            if len(content.split('\n')) > 25:
                arrow_message("...")
                arrow_message(f"Full summary available at: {summary_file}")

        except Exception as e:
            status_message(f"Error reading summary: {e}", False)
    else:
        status_message("PROJECT_SUMMARY.md not found", False)
        arrow_message("You can regenerate it by adding features or reconfiguring the project")


def open_project_folder(folder):
    """Open project folder in file manager."""
    import subprocess
    import platform

    try:
        system = platform.system()
        if system == "Windows":
            subprocess.run(["explorer", str(folder)])
        elif system == "Darwin":  # macOS
            subprocess.run(["open", str(folder)])
        else:  # Linux
            subprocess.run(["xdg-open", str(folder)])

        status_message(f"‚úÖ Opened project folder: {folder}", True)
    except Exception as e:
        status_message(f"‚ùå Failed to open folder: {e}", False)
        arrow_message(f"Please manually navigate to: {folder}")


def reset_project_config(data, folder):
    """Reset project configuration."""
    project_name = data.get("project_name", "Unknown")

    boxed_message("‚ö†Ô∏è  Reset Project Configuration")
    rich_message("This will:")
    arrow_message("‚Ä¢ Remove LaunchKIT-specific configuration files")
    arrow_message("‚Ä¢ Keep your source code intact")
    arrow_message("‚Ä¢ Allow you to reconfigure the project from scratch")

    confirm = Question(f"Are you sure you want to reset '{project_name}' configuration?",
                       ["Yes, Reset", "No, Cancel"]).ask()

    if "Yes" in confirm:
        progress_message("Resetting project configuration...")

        # Stop any running services first
        cleanup_processes()

        # Files to remove
        config_files = [
            "PROJECT_SUMMARY.md",
            "data.json",
            ".launchkit"
        ]

        removed_files = []
        for file_name in config_files:
            file_path = folder / file_name
            try:
                if file_path.exists():
                    if file_path.is_file():
                        file_path.unlink()
                        removed_files.append(file_name)
                    elif file_path.is_dir():
                        import shutil
                        shutil.rmtree(file_path)
                        removed_files.append(file_name)
            except Exception as e:
                status_message(f"Failed to remove {file_name}: {e}", False)

        if removed_files:
            status_message("‚úÖ Project configuration reset successfully!", True)
            for file in removed_files:
                arrow_message(f"Removed: {file}")
        else:
            status_message("No configuration files found to remove", True)

        rich_message("You can run LaunchKIT again to reconfigure this project")
        arrow_message("Your source code and dependencies remain unchanged")
    else:
        status_message("Configuration reset cancelled", True)


def create_flask_production_config(folder):
    """Create production configuration for Flask projects."""
    try:
        # Create a basic production config
        prod_config = '''import os
from pathlib import Path

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
'''

        config_file = folder / "config.py"
        if not config_file.exists():
            config_file.write_text(prod_config)

        # Create requirements.txt if it doesn't exist
        req_file = folder / "requirements.txt"
        if not req_file.exists():
            basic_requirements = '''Flask==2.3.3
python-dotenv==1.0.0
gunicorn==21.2.0
'''
            req_file.write_text(basic_requirements)

        status_message("‚úÖ Flask production configuration created!", True)
        arrow_message("Created: config.py")
        arrow_message("Updated: requirements.txt")

    except Exception as e:
        status_message(f"‚ùå Failed to create Flask production config: {e}", False)


def deploy_app(data, folder):
    """Handle deployment options."""
    addons = data.get("addons", [])

    deploy_options = ["Manual Deployment Guide"]

    if "Add Docker Support" in addons:
        deploy_options.append("Deploy with Docker")

    if "Add Kubernetes Support" in addons:
        deploy_options.append("Deploy to Kubernetes")

    if "Add CI (GitHub Actions)" in addons:
        deploy_options.append("Setup Automated Deployment")

    deploy_choice = Question("Select deployment option:", deploy_options).ask()

    if deploy_choice == "Deploy with Docker":
        deploy_with_docker(data)
    elif deploy_choice == "Deploy to Kubernetes":
        deploy_to_kubernetes(data)
    elif deploy_choice == "Setup Automated Deployment":
        setup_automated_deployment(data)
    else:
        show_manual_deployment_guide(data)
